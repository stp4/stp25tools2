% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tbll_likert.R
\name{Tbll_likert}
\alias{Tbll_likert}
\title{Tbll_likert}
\usage{
Tbll_likert(
  x,
  ...,
  include.reference = NULL,
  include.mean = TRUE,
  include.n = FALSE,
  include.na = FALSE,
  include.order = FALSE,
  include.percent = TRUE,
  include.count = TRUE,
  include.total = FALSE,
  exclude.levels = NULL,
  decreasing = TRUE,
  reference.labels = c("low", "neutral", "high"),
  reverse.levels = FALSE,
  reorder.levels = NA
)
}
\arguments{
\item{x}{A \code{data.frame} or a Likert object created by \code{Summarise_likert()}.}

\item{...}{Additional arguments passed to \code{Summarise_likert()} or \code{prepare.data()}.}

\item{include.reference}{Numeric. Defines how reference groups are calculated:
* \code{2} → three groups (e.g. low, neutral, high)
* \code{2.5} → two groups (e.g. disagree vs. agree)
* \code{3} → three groups with the neutral category kept separate.
Use together with \code{reference.labels}.}

\item{include.mean}{Logical. If \code{TRUE}, include mean values in the output.}

\item{include.n}{Logical. If \code{TRUE}, include the sample size per item.}

\item{include.na}{Logical. If \code{TRUE}, missing values are shown and included
in the percentage calculation.}

\item{include.order}{Logical. If \code{TRUE}, items are sorted by their mean value.}

\item{include.percent}{Logical. If \code{TRUE}, percentages are included.}

\item{include.count}{Logical. If \code{TRUE}, counts are included.}

\item{include.total}{Logical or string. If \code{TRUE} or a label (e.g. \code{"All"}),
adds a row with total results across all groups.}

\item{exclude.levels}{Integer. Position(s) of levels to exclude (e.g.
\code{exclude.levels = 5} is equivalent to \code{reorder.levels = -5}).}

\item{decreasing}{Logical. If \code{TRUE} (default), sorting is in decreasing order.}

\item{reference.labels}{Character vector of labels for the reference groups
(default: \code{c("low", "neutral", "high")}).}

\item{reverse.levels}{Logical. If \code{TRUE}, reverses the order of levels.}

\item{reorder.levels}{Integer vector. Reorder factor levels using
\code{factor(item, levels(item)[reorder.levels])}.}
}
\value{
A tibble with grouped Likert summary statistics (percentages, counts,
  means, missing values, etc.).
}
\description{
Create a summary table for Likert-type items.
}
\details{
This function extracts and formats results from \code{Summarise_likert()}.
It provides flexible options to include mean values, counts,
percentages, missing data, and reference groupings.
}
\examples{
require(dplyr)
require(tibble)
set.seed(42)

levels <- c(
  "Strongly disagree", "Disagree", "Neither agree nor disagree",
  "Agree", "Strongly agree")

n <- 2*3*9*3
DF_lik <- tibble(
  q1 = sample(levels, n, replace = TRUE, prob = c(3,2, 1, 4,5)),
  q2 = sample(levels, n, replace = TRUE, prob = c(3,1, 1, 1,1)),
  q3 = sample(levels, n, replace = TRUE, prob = c(7,5, 1, 0,0)),
  q4 = sample(levels, n, replace = TRUE, prob = c(0,0, 0, 1,5)),
  q5 = sample(levels, n, replace = TRUE, prob = c(1,4, 1, 1,5)),
  q6 = sample(levels, n, replace = TRUE, prob = c(2,3, 0, 2,3)),
  q7 = sample(levels, n, replace = TRUE, prob = c(3,2, 0, 1,7)),
  q8 = sample(levels, n, replace = TRUE, prob = c(1,2, 1, 4,1)),
  q9 = sample(levels, n, replace = TRUE, prob = c(6,0, 0, 0,6))
) |>
  mutate(across(everything(), ~ factor(.x, levels = levels))) |>
  mutate(Sex = factor(sample(c("male", "female"), n, replace = TRUE)),
         Age = factor(sample(c("18-30", "30-50", ">50"), n, replace = TRUE)))

# Basic usage:
DF_lik |>
  Summarise_likert(q1, q2, q3, q4, by = ~ Sex) |>
  Tbll_likert()

# With ordering
DF_lik |>
  Tbll_likert(q1, q2, q3, q4, by = ~ Sex, include.order = TRUE)

# Using reference groups
DF_lik |>
  Tbll_likert(
    "FC.2", q1, q2,
    "FC.3", q3, q4, q5,
    "FC.4", q6, q7, q8, q9,
    by = ~ Sex,
    include.count = FALSE,
    include.reference = 2.5,
    reference.labels = c("disagree", "agree"),
    include.total = TRUE,
    include.n = TRUE,
    include.na = TRUE,
    include.mean = TRUE)
}
