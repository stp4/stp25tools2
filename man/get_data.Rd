% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_data.R
\name{get_data}
\alias{get_data}
\title{Import a dataset from various formats or from inline text}
\usage{
get_data(
  file = NA_character_,
  na.strings = NULL,
  dec = ".",
  sep = ";",
  as_tibble = TRUE,
  sheet = 1,
  range = NULL,
  skip = 0,
  header = TRUE,
  fill = TRUE,
  comment.char = "",
  quote = "\\"",
  encoding = NULL,
  user_na = FALSE,
  cleanup.names = TRUE,
  cleanup.encoding = FALSE,
  cleanup.factor = TRUE,
  from = "UTF8",
  to = "latin1",
  tabel_expand = FALSE,
  id.vars = 1,
  value = "value",
  label = 0,
  ...
)
}
\arguments{
\item{file}{Path to a data file (`.xlsx`, `.sav`, `.csv`) or a character string containing table-like text.}

\item{na.strings}{Character vector of strings to be interpreted as missing values (default: `c("NA", "na")`).}

\item{dec}{Decimal separator (default: `.`).}

\item{sep}{Field separator character (default: `";"` for CSV; whitespace for inline text).}

\item{as_tibble}{Logical; if `TRUE`, convert output to tibble, otherwise to data.frame.}

\item{sheet}{Sheet number or name (Excel only, passed to [readxl::read_excel()]).}

\item{range}{Cell range to read (Excel only).}

\item{skip}{Number of lines to skip before reading data.}

\item{header}{Logical; whether the first line of a CSV file contains column names.}

\item{fill}{Logical; for CSV import, fill rows with unequal length.}

\item{comment.char}{Character: comment character for CSV files.}

\item{quote}{Quoting character for CSV files.}

\item{encoding}{File encoding (SPSS only, passed to [haven::read_sav()]).}

\item{user_na}{Logical; for SPSS files, if `TRUE`, keep user-defined missing values as labelled objects.}

\item{cleanup.names}{Logical; if `TRUE`, clean column names via `fix_names()`.}

\item{cleanup.encoding}{Logical; if `TRUE`, run `names_label_encoding()`, `character_encoding()`, and `factor_levels_encoding()` on the data.}

\item{cleanup.factor}{Logical; if `TRUE`, clean factor variables.}

\item{from}{Source encoding (used with `cleanup.encoding`).}

\item{to}{Target encoding (used with `cleanup.encoding`).}

\item{tabel_expand}{Logical; if `TRUE`, expand frequency tables to long format via `expand_table()`.}

\item{id.vars}{Variable indices or names to be treated as ID variables when `tabel_expand = TRUE`.}

\item{value}{Name of the output value column when `tabel_expand = TRUE`.}

\item{label}{Integer or character: position or name of a row containing variable labels (0 = no labels).}

\item{...}{Additional arguments passed to underlying read functions or to `expand_table()`.}
}
\value{
A data frame or tibble containing the imported dataset.
}
\description{
Reads data from a file (`.xlsx`, `.csv`, `.sav`) or from a text string directly embedded in an R script.
}
\note{
xlsx: readxl::read_excel(file, sheet, skip, range)

 csv:   read.table(file, header, sep, quote, dec, na.strings, skip, fill, comment.char)

 sav:  haven::read_sav(file, encoding,  user_na)

 text: read.text2(file, dec)
}
\examples{
dat <- get_data("
sex treatment control
m  2 3
f  3 4
",
                tabel_expand = TRUE,
                id.vars = 1)

xtabs(~ sex + value, dat)

dat <- get_data(
  "
sex treatment  neg  pos
f   KG          3   3
f   UG          4   5
m   KG          5   4
m   UG          4   2
",
  tabel_expand = TRUE,
  id.vars = 1:2,
  value = "befund"
)

ftable(xtabs(~ sex + treatment + befund, dat))

\dontrun{
if (file.exists("inst/extdata/dummy.csv")) {
  get_data("inst/extdata/dummy.csv", dec = ",", na.strings = "-", skip = 1, label = 1)
  get_data("inst/extdata/dummy.xlsx", na.strings = "-")
  get_data("inst/extdata/dummy.sav")
}
}
}
